# -*- coding: utf-8 -*-
"""Hands on - 8

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sJLy2j6wRLo2PaqwCCMR7J2ZimXrv2x4
"""

#  ith Order Statistic using Quicksort
import random

def partition(arr, low, high):
    pivot_index = random.randint(low, high)
    pivot_value = arr[pivot_index]

    # Move pivot to end
    arr[pivot_index], arr[high] = arr[high], arr[pivot_index]
    store_index = low

    for i in range(low, high):
        if arr[i] < pivot_value:
            arr[store_index], arr[i] = arr[i], arr[store_index]
            store_index += 1

    # Move pivot to its final place
    arr[store_index], arr[high] = arr[high], arr[store_index]
    return store_index

def quickselect(arr, low, high, i):
    if low == high:
        return arr[low]

    pivot_index = partition(arr, low, high)

    # The pivot is in its final sorted position
    if i == pivot_index:
        return arr[pivot_index]
    elif i < pivot_index:
        return quickselect(arr, low, pivot_index - 1, i)
    else:
        return quickselect(arr, pivot_index + 1, high, i)

def ith_order_statistic(arr, i):
    if i < 0 or i >= len(arr):
        raise ValueError("Index is out of bounds")
    return quickselect(arr, 0, len(arr) - 1, i)

# Example
arr = [3, 2, 1, 5, 4]
i = 2  # Looking for the 3rd smallest element (index 2)
result = ith_order_statistic(arr, i)
print(f"The {i+1}th smallest element is: {result}")

#  Stack Implementation
class Stack:
    def __init__(self, size):
        self.size = size
        self.stack = [0] * size
        self.top = -1

    def is_empty(self):
        return self.top == -1

    def is_full(self):
        return self.top == self.size - 1

    def push(self, item):
        if self.is_full():
            raise IndexError("Stack overflow")
        self.top += 1
        self.stack[self.top] = item

    def pop(self):
        if self.is_empty():
            raise IndexError("Stack underflow")
        item = self.stack[self.top]
        self.top -= 1
        return item

    def peek(self):
        if self.is_empty():
            raise IndexError("Stack is empty")
        return self.stack[self.top]

# Example
stack = Stack(5)
stack.push(1)
stack.push(2)
print(stack.pop())
print(stack.peek())

# Queue Implementation
class Queue:
    def __init__(self):
        self.queue = []

    def is_empty(self):
        return len(self.queue) == 0

    def enqueue(self, item):
        self.queue.append(item)

    def dequeue(self):
        if self.is_empty():
            raise IndexError("Queue underflow")
        return self.queue.pop(0)

    def peek(self):
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.queue[0]

# Example Usage
queue = Queue()
queue.enqueue(5)
queue.enqueue(10)
print(queue.dequeue())  # Output: 5
print(queue.peek())  # Output: 10

# Singly Linked List Implementation
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            return
        last = self.head
        while last.next:
            last = last.next
        last.next = new_node

    def display(self):
        current = self.head
        while current:
            print(current.data, end=" -> ")
            current = current.next
        print("None")

# Example Usage
sll = SinglyLinkedList()
sll.append(1)
sll.append(2)
sll.display()  # Output: 1 -> 2 -> None